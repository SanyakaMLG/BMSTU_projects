(load "stream.scm")
(load "unit-test.scm")

; <fraction> ::= <nomenator><denominator>
; <nomenator> ::= <number with sign>
; <denominator> ::= /<number>
; <number with sign> ::= +<number> | -<number> | <number>
; <number> ::= DIGIT <number> | DIGIT

(define (scan str)
  (let* ((EOF (integer->char 0))
         (stream (make-stream (string->list str) EOF)))
    
    (call-with-current-continuation
     (lambda (error)
       (define result (tokens stream error))
       (and (equal? (peek stream) EOF)
            result)))))

(define (tokens stream error)
  (define (start-token? char)
    (or (char-numeric? char)
        (equal? char #\/)
        (equal? char #\+)
        (equal? char #\-)))
  (cond ((char-whitespace? (peek stream))
         (spaces stream error)
         (cons #\space (tokens stream error)))
        ((start-token? (peek stream))
         (cons (token stream error)
               (tokens stream error)))
        (else '())))

(define (spaces stream error)
  (cond ((char-whitespace? (peek stream))
         ;(if (char-whitespace? (peek stream))
         ;    (next stream)
         ;    (error #f))
         (next stream)
         (spaces stream error))
        (else #t)))

(define (token stream error)
  (cond ((equal? (peek stream) #\/) (next stream))
        ((equal? (peek stream) #\+) (next stream))
        ((equal? (peek stream) #\-) (next stream))
        ((char-numeric? (peek stream)) (next stream))
        (else (error #f))))

(define (check-frac str)
  (and (scan str)
       (let* ((EOF (integer->char 0))
              (stream (make-stream (scan str))))
  
         (call-with-current-continuation
          (lambda (error)
            (sequence stream error)
            (equal? (peek stream) #f))))))

(define (sequence stream error)
  (cond ((start-nomen? (peek stream))
         (nomen stream error)
         (and (start-denom? (peek stream))
              (denom stream error)))
        (else (error #f))))

(define (start-nomen? token)
  (or (equal? token #\+)
      (equal? token #\-)
      (and (not (equal? token #f))
           (char-numeric? token))))

(define (start-denom? token)
  (equal? token #\/))

(define (nomen stream error)
  (if (start-nomen? (peek stream))
      (parse-nomen stream error)
      (error #f)))

(define (parse-nomen stream error)
  (cond ((equal? (peek stream) #\-)
         (next stream)
         (if (and (not (equal? (peek stream) #f))
                  (char-numeric? (peek stream)))
             (next stream)
             (error #f))
         (number stream error))
        ((equal? (peek stream) #\+)
         (next stream)
         (if (and (not (equal? (peek stream) #f))
                  (char-numeric? (peek stream)))
             (next stream)
             (error #f))
         (number stream error))
        ((char-numeric? (peek stream))
         (next stream)
         (number stream error))
        (else (error #f))))

(define (number stream error)
  (cond ((equal? (peek stream) #f) #t)
        ((char-numeric? (peek stream))
         (next stream)
         (number stream error))
        (else #t)))

(define (denom stream error)
  (if (start-denom? (peek stream))
      (parse-denom stream error)
      (error #f)))

(define (parse-denom stream error)
  (cond ((equal? (peek stream) #\/)
         (next stream)
         (if (and (not (equal? (peek stream) #f))
                  (char-numeric? (peek stream)))
             (next stream)
             (error #f))
         (number stream error))
        (else (error #f))))
         

(define (scan-frac str)
  (and (check-frac str)
       (string->number str)))

(define (scan-many str)
  (let loop((xs (scan str))
            (res '())
            (ress '()))
    (and xs
         (if (null? xs)
             (if (not (null? res))
                 (reverse (cons (reverse res) ress))
                 (reverse ress))
             (if (char-whitespace? (car xs))
                 (if (not (null? res))
                     (loop (cdr xs) '() (cons (reverse res) ress))
                     (loop (cdr xs) '() ress))
                 (loop (cdr xs) (cons (car xs) res) ress))))))

(define (scan-many-fracs str)
  (and (scan-many str)
       (let loop((xs (scan-many str))
                 (res '()))
         (if (null? xs)
             (and (not (null? res)) (reverse res))
             (and (check-frac (list->string (car xs)))
                  (loop (cdr xs) (cons (scan-frac (list->string (car xs))) res)))))))

(define the-tests
  (list (test (check-frac "110/111") #t)
        (test (check-frac "-4/3") #t)
        (test (check-frac "+5/10") #t)
        (test (check-frac "5.0/10") #f)
        (test (check-frac "FF/10") #f)
        (test (check-frac "-") #f)
        (test (check-frac "111/112/113") #f)
        (test (check-frac "+10/4-5") #f)
        (test (check-frac "1/") #f)
        (test (check-frac "/3") #f)
        (test (check-frac "") #f)
        (test (scan-frac "110/111") 110/111)
        (test (scan-frac "-4/3") -4/3)
        (test (scan-frac "+5/10") 1/2)
        (test (scan-frac "5.0/10") #f)
        (test (scan-frac "FF/10") #f)
        (test (scan-frac "-") #f)
        (test (scan-frac "111/112/113") #f)
        (test (scan-frac "+10/4-5") #f)
        (test (scan-frac "1/") #f)
        (test (scan-frac "/3") #f)
        (test (scan-frac "") #f)
        (test (scan-many-fracs "\t1/2 1/3\n\n10/8") (1/2 1/3 5/4))
        (test (scan-many-fracs "\t1/2 1/3\n\n2/-5") #f)))

(run-tests the-tests)
